package cid_source

import (
	"math/rand"
	"time"

	"github.com/cortze/ipfs-cid-hoarder/pkg/config"

	"github.com/ipfs/go-cid"
	ma "github.com/multiformats/go-multiaddr"
	mh "github.com/multiformats/go-multihash"
	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"
)

type RandomCidGen struct {
	contentSize int
	//keeps track of how many cids have been generated by the random cid gen struct
	cidsGenerated int
	//limit of how many cids to generate
	limit int
}

func NewRandomCidGen(contentSize int, limit int) *RandomCidGen {
	return &RandomCidGen{
		contentSize:   contentSize,
		cidsGenerated: 0,
		limit:         limit,
	}
}

func (g *RandomCidGen) Type() string {
	return config.RandomSource
}

// TODO: is it worth keeping the content?
// getRandomContent returns generates an array of random bytes with the given size and the composed CID of the content
func (g *RandomCidGen) GetNewCid() (TrackableCid, error) {
	if g.cidsGenerated >= g.limit {
		return TrackableCid{}, errors.New("done generating cids")
	}
	g.cidsGenerated++
	// generate random bytes
	content := make([]byte, g.contentSize)
	rand.Read(content)

	//TODO do we have to have different CID types?
	// configure the type of CID that we want
	pref := cid.Prefix{
		Version:  1,
		Codec:    cid.Raw,
		MhType:   mh.SHA2_256,
		MhLength: -1,
	}

	// get the CID of the content we just generated
	contID, err := pref.Sum(content)
	if err != nil {
		return TrackableCid{}, errors.Wrap(err, "composing CID")
	}

	log.Infof("generated new CID %s", contID.Hash().B58String())
	ProvidersAndCidInstance := NewTrackableCid("", contID, "", make([]ma.Multiaddr, 0), time.Now(), 0, "")
	return ProvidersAndCidInstance, nil
}
