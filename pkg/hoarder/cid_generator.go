package hoarder

import (
	"context"
	"math/rand"
	"sync"

	"github.com/ipfs/go-cid"
	mh "github.com/multiformats/go-multihash"
	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"
)

var (
	CidLimitError error = errors.New("limit of cids reached")
)

// CidGenerator composes the basic object that generates set of CIDs defined in the configuration
type CidGenerator struct {
	ctx       context.Context
	hoarderWG *sync.WaitGroup
	generatorWG       *sync.WaitGroup

	contentSize int
	cidNumber   int

	generator *randomCidGen
	newCidC   chan *cid.Cid
	doneC     chan struct{}
	doneNotC chan struct{}
}

// NewCidTracker generates a new instance of the CIDTracker
func NewCidGenerator(
	ctx context.Context,
	hoarderWG *sync.WaitGroup,
	cSize, cNumber int) *CidGenerator {

	return &CidGenerator{
		ctx:         ctx,
		hoarderWG:   hoarderWG,
		generatorWG: new(sync.WaitGroup),
		contentSize: cSize,
		cidNumber:   cNumber,
		generator:   newRandomCidGen(cSize, cNumber),
		newCidC:     make(chan *cid.Cid, 1),
		doneC:       make(chan struct{}, 1),
		doneNotC:       make(chan struct{}, 1),
	}
}

// Generates cids depending on the cid source
func (g *CidGenerator) Run() (chan *cid.Cid, chan struct{}) {
	g.generatorWG.Add(1)
	go func() {
		defer g.generatorWG.Done()
		for {
			select {
			case <-g.ctx.Done():
				log.Info("context shutdown detected on CidGenerator")
				return
			case <-g.doneC:
				log.Info("controled shutdown detected on CidGenerator")
				return 
			default:
				contId, err := g.generator.getNewCid()
				switch err {
				case CidLimitError:
					log.Infof("Cid generation marked reached: %d, clossing generator", g.cidNumber)
					return
				case nil:
					log.Infof("generated new CID %s", contId.Hash().B58String())
					g.newCidC <- &contId
				default:
					log.Error("Error generating new CID: %s", err.Error())
				}
			}
		}
	}()
	return g.newCidC, g.doneNotC
}

func (g *CidGenerator) Close() {
	g.doneC <- struct{}{}
	g.generatorWG.Wait()
	g.hoarderWG.Done()
	log.Info("cid generator successfully closed")
	g.doneNotC <- struct{}{}
	close(g.doneC)
	close(g.doneNotC)
}

type randomCidGen struct {
	contentSize int
	//keeps track of how many cids have been generated by the random cid gen struct
	cidsGenerated int
	//limit of how many cids to generate (-1 to run it contineously)
	limit int
}

func newRandomCidGen(contentSize int, limit int) *randomCidGen {
	return &randomCidGen{
		contentSize:   contentSize,
		cidsGenerated: 0,
		limit:         limit,
	}
}

// getRandomContent returns generates an array of random bytes with the given size and the composed CID of the content
func (g *randomCidGen) getNewCid() (cid.Cid, error) {
	if g.cidsGenerated >= g.limit {
		return cid.Cid{}, CidLimitError
	}

	g.cidsGenerated++
	// generate random bytes
	content := make([]byte, g.contentSize)
	rand.Read(content)

	//TODO do we have to have different CID types?
	// configure the type of CID that we want
	pref := cid.Prefix{
		Version:  1,
		Codec:    cid.Raw,
		MhType:   mh.SHA2_256,
		MhLength: -1,
	}

	// get the CID of the content we just generated
	contID, err := pref.Sum(content)
	if err != nil {
		return cid.Cid{}, errors.Wrap(err, "composing CID")
	}
	return contID, nil
}
